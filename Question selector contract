# Handover: Pydantic Contracts for V3

**Date:** December 16, 2025
**Status:** Planning document for future implementation
**Priority:** V3 - Before provenance, confidence tracking, and contradiction detection

---

## Context

During V2 code review, we identified that the Question Selector V2 (and other modules) have implicit contracts that are enforced through runtime checks and documentation rather than type-safe structures. This creates several risks:

1. **Silent degradation** - Wrong types pass through without errors
2. **Contract drift** - Documentation and code diverge over time
3. **Difficult debugging** - Type mismatches surface far from their source
4. **Provenance complexity** - Hard to attach metadata to untyped dicts

The V2 fixes added defensive copies and input validation, but these are band-aids. Pydantic contracts provide a proper foundation for V3 features.

---

## Why Contracts Before Provenance

The V3 feature order should be:

1. **Contracts** (this task)
2. **Provenance** - tracking where values came from
3. **Confidence tracking** - validation scores per field
4. **Contradiction detection** - comparing historical snapshots

Rationale:

- **Provenance needs typed structures** - "Where did this value come from?" requires a stable field to attach that metadata to. Raw dicts make this messy.

- **Confidence tracking needs field validators** - Pydantic's field validators are perfect for attaching confidence scores and validation rules at the field level.

- **Contradiction detection needs immutable snapshots** - Frozen Pydantic models give you immutable snapshots you can compare across time.

---

## Proposed Contracts

### 1. EpisodeStateInput

What the Question Selector is allowed to read from State Manager.

```python
from pydantic import BaseModel, Field
from typing import Optional, Set, Any
from datetime import datetime

class EpisodeStateInput(BaseModel):
    """
    Input contract for Question Selector V2.
    
    Represents the episode state passed to get_next_question(),
    check_triggers(), and is_block_complete().
    """
    
    # Required tracking sets
    questions_answered: Set[str] = Field(
        description="Set of question IDs that have been answered"
    )
    follow_up_blocks_activated: Set[str] = Field(
        description="Set of block IDs that have been triggered"
    )
    follow_up_blocks_completed: Set[str] = Field(
        description="Set of block IDs where all questions are done"
    )
    
    # Episode metadata (optional - not all callers have this)
    episode_id: Optional[int] = Field(
        default=None,
        description="Episode identifier (1-indexed)"
    )
    
    # Extracted clinical fields (dynamic)
    # These are the actual answers from the consultation
    # Using extra='allow' to accept any field names
    
    class Config:
        extra = 'allow'  # Allow dynamic clinical fields
        frozen = True    # Immutable after creation
```

**Design decisions:**

- `frozen = True` - Immutable after creation, safe to pass around
- `extra = 'allow'` - Accepts dynamic clinical fields (vl_laterality, h_present, etc.)
- Required fields are explicit, clinical fields are dynamic
- Set types enforced (no more list/set ambiguity)

### 2. QuestionOutput

Immutable view of a question returned by selector.

```python
from pydantic import BaseModel, Field
from typing import Optional, List, Dict, Any

class QuestionOutput(BaseModel):
    """
    Output contract for Question Selector V2.
    
    Represents a question returned by get_next_question().
    This is a copy - mutations do not affect the ruleset.
    """
    
    id: str = Field(description="Unique question identifier")
    question: str = Field(description="Question text to display")
    field: str = Field(description="Target field name for extraction")
    field_type: str = Field(
        default="text",
        description="Field type: boolean, categorical, text, integer"
    )
    type: str = Field(
        default="probe",
        description="Question type: probe or conditional"
    )
    
    # Optional fields
    condition: Optional[str] = Field(
        default=None,
        description="Condition name (for conditional questions)"
    )
    valid_values: Optional[List[str]] = Field(
        default=None,
        description="Valid values for categorical fields"
    )
    definitions: Optional[Dict[str, str]] = Field(
        default=None,
        description="Value definitions for categorical fields"
    )
    comment: Optional[str] = Field(
        default=None,
        description="Internal comment (not shown to user)"
    )
    
    class Config:
        frozen = True  # Immutable - caller cannot corrupt ruleset
```

**Design decisions:**

- All question fields explicitly typed
- `frozen = True` - Replaces defensive copy, immutable by design
- No `extra = 'allow'` - Questions have known structure

### 3. TriggerResult

Explicit structure for trigger evaluation results.

```python
from pydantic import BaseModel, Field
from typing import Set, Dict, Optional

class TriggerResult(BaseModel):
    """
    Output contract for check_triggers().
    
    Provides activated block IDs with optional provenance.
    """
    
    activated_blocks: Set[str] = Field(
        description="Block IDs whose conditions are currently met"
    )
    
    # Future: provenance tracking
    # trigger_reasons: Optional[Dict[str, str]] = Field(
    #     default=None,
    #     description="Map of block_id -> trigger_name that activated it"
    # )
    
    class Config:
        frozen = True
```

**Design decisions:**

- Currently just wraps a set (same as current return)
- Structure allows adding provenance later ("why did this trigger fire?")
- Frozen for consistency

### 4. DSLCondition (Future - Optional)

Typed DSL structure for compile-time validation.

```python
from pydantic import BaseModel, Field, validator
from typing import Union, List, Literal, Tuple

class DSLCondition(BaseModel):
    """
    Typed DSL condition structure.
    
    Allows compile-time validation of ruleset conditions.
    """
    
    # Logical operators
    all_: Optional[List['DSLCondition']] = Field(default=None, alias='all')
    any_: Optional[List['DSLCondition']] = Field(default=None, alias='any')
    
    # Comparison operators
    eq: Optional[Tuple[str, Any]] = None
    ne: Optional[Tuple[str, Any]] = None
    gt: Optional[Tuple[str, float]] = None
    gte: Optional[Tuple[str, float]] = None
    lt: Optional[Tuple[str, float]] = None
    lte: Optional[Tuple[str, float]] = None
    
    # Boolean operators
    is_true: Optional[str] = None
    is_false: Optional[str] = None
    
    # Other operators
    exists: Optional[str] = None
    contains_lower: Optional[Tuple[str, str]] = None
    
    @validator('*', pre=True)
    def only_one_operator(cls, v, values):
        # Ensure only one operator per condition
        set_values = [k for k, v in values.items() if v is not None]
        if len(set_values) > 1:
            raise ValueError(f"Multiple operators in single condition: {set_values}")
        return v
    
    class Config:
        extra = 'forbid'  # No unknown operators allowed
```

**Note:** This is more complex and may not be needed for V3. Consider deferring.

---

## Implementation Plan

### Phase 1: Add Pydantic Dependency

1. Add pydantic to requirements/environment
2. Verify compatibility with existing stack (Python 3.11+, WSL2)
3. Pydantic v2 preferred (faster, better validation)

### Phase 2: Create Contract Models

1. Create `backend/contracts/` directory
2. Implement `EpisodeStateInput`
3. Implement `QuestionOutput`
4. Implement `TriggerResult`
5. Add unit tests for each model

### Phase 3: Integrate with Question Selector V2

1. Update `get_next_question()`:
   - Accept `EpisodeStateInput` (or dict that validates to it)
   - Return `QuestionOutput` (or None)
   
2. Update `check_triggers()`:
   - Accept `EpisodeStateInput`
   - Return `TriggerResult`
   
3. Update `is_block_complete()`:
   - Accept `EpisodeStateInput`
   - Return bool (no change)

4. Backwards compatibility:
   - Accept raw dicts and validate internally
   - Or require callers to create models (breaking change)

### Phase 4: Integrate with Other Modules

1. **State Manager V2**: Add `get_episode_for_selector()` returning `EpisodeStateInput`
2. **Dialogue Manager V2**: Update to work with typed returns
3. **Response Parser**: Consider `ExtractionResult` contract

### Phase 5: Prepare for Provenance

1. Add optional provenance fields to contracts
2. Design `ProvenanceMetadata` model
3. Plan how provenance attaches to field values

---

## Files to Create

```
backend/
â”œâ”€â”€ contracts/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ episode_state.py      # EpisodeStateInput
â”‚   â”œâ”€â”€ question.py           # QuestionOutput
â”‚   â”œâ”€â”€ trigger.py            # TriggerResult
â”‚   â””â”€â”€ provenance.py         # ProvenanceMetadata (Phase 5)
```

---

## Migration Strategy

**Option A: Big Bang (Not Recommended)**
- Update all modules at once
- High risk, hard to debug

**Option B: Gradual Migration (Recommended)**
1. Add contracts alongside existing code
2. Validate internally, accept raw dicts at boundary
3. Migrate one module at a time
4. Eventually require typed inputs

**Example gradual migration:**

```python
def get_next_question(self, episode_data: dict | EpisodeStateInput) -> QuestionOutput | None:
    """
    Get next question for episode.
    
    Args:
        episode_data: Episode state (dict or EpisodeStateInput)
    """
    # Validate/convert to typed model
    if isinstance(episode_data, dict):
        episode = EpisodeStateInput(**episode_data)
    else:
        episode = episode_data
    
    # ... rest of logic using typed episode ...
    
    if question_dict is None:
        return None
    
    return QuestionOutput(**question_dict)
```

---

## Testing Strategy

1. **Model validation tests** - Verify models accept/reject correct data
2. **Serialization tests** - Verify JSON round-trip works
3. **Integration tests** - Verify modules work with typed contracts
4. **Regression tests** - Verify existing functionality unchanged

---

## Risks and Mitigations

| Risk | Impact | Mitigation |
|------|--------|------------|
| Pydantic v2 breaking changes | Medium | Pin version, test thoroughly |
| Performance overhead | Low | Pydantic v2 is fast, profile if needed |
| Migration complexity | Medium | Gradual migration, backwards compat |
| Extra = 'allow' hides typos | Medium | Add known field validators |
| Circular imports | Low | Keep contracts in separate package |

---

## Success Criteria

1. All three core contracts implemented and tested
2. Question Selector V2 uses typed inputs/outputs
3. No regressions in existing tests
4. Documentation updated
5. Ready for provenance phase

---

## Related Documents

- `Module_architecture_V3` - Overall system design
- `state_manager_formatter_contract_v1.json` - Existing contract (JSON format)
- `question_selector_v2.py` - Module to integrate first
- `Version_4-8_update_plan` - V3 feature roadmap

---

## Questions to Resolve

1. **Pydantic v1 or v2?** - v2 recommended but verify compatibility
2. **Strict or gradual migration?** - Gradual recommended
3. **DSLCondition typed model?** - Defer unless needed for validation
4. **Contract location?** - `backend/contracts/` or `backend/core/contracts/`?
5. **Should State Manager return typed models?** - Yes, eventually

---

## Estimated Effort

| Phase | Effort | Dependencies |
|-------|--------|--------------|
| Phase 1: Add Pydantic | 1 hour | None |
| Phase 2: Create Models | 2-3 hours | Phase 1 |
| Phase 3: Question Selector | 2-3 hours | Phase 2 |
| Phase 4: Other Modules | 4-6 hours | Phase 3 |
| Phase 5: Provenance Prep | 2-3 hours | Phase 4 |

**Total: ~12-16 hours**

---

## Next Steps

1. Review this plan and approve approach
2. Add Pydantic to project dependencies
3. Create contracts package structure
4. Implement EpisodeStateInput first (most critical)
5. Integrate with Question Selector V2
6. Proceed to other modules

---

**End of Handover Document**
